/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2017 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.locationupdatesservice;

import java.util.Timer;
import java.util.TimerTask;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiApplication;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.support.v4.content.LocalBroadcastManager;
import android.graphics.Bitmap;
import android.location.Location;
import android.os.IBinder;
import android.preference.PreferenceManager;

@Kroll.module(name = "Locationupdatesservice", id = "ti.locationupdatesservice")
public class LocationupdatesserviceModule extends KrollModule {
	private static final String PACKAGE_NAME = TiApplication.getInstance()
			.getPackageName();

	static final String ACTION_BROADCAST = PACKAGE_NAME + ".broadcast";
	// The BroadcastReceiver used to listen from broadcasts from the service.
	private MyReceiver myReceiver;
	static final String EXTRA_LOCATION = PACKAGE_NAME + ".location";
	private static final String EXTRA_STARTED_FROM_NOTIFICATION = PACKAGE_NAME
			+ ".started_from_notification";
	// Standard Debugging variables
	public static final String LCAT = "TiGeoLogger";
	private Context ctx;
	public static String dbName = "geologger";
	public static String notificationChannel = "channel1";
	public static String notificationIcon = null;

	public static String notificationName = "";
	public static Bitmap cancelIcon;
	public static Bitmap launchIcon;
	public static String startTracking = "Start";
	public static String stopTracking = "Stop";

	public static int interval = 0;
	public static int duration = 0;
	public static String rootActivityClassName = "";
	final static String ACTION = "LocationUpdatesServiceAction";
	final static int RQS_STOP_TRACKER = 0;
	final static int RQS_START_TRACKER = 1;
	final static int RQS_REMOVE_TRACKER = 2;
	final static String SERVICE_COMMAND_KEY = "SERVICECOMMANDKEY";
	SharedPreferences sharedPreferences;
	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	// A reference to the service used to get location updates.
	private LocationUpdatesService mService = null;

	// Tracks the bound state of the service.
	private boolean mBound = false;

	public LocationupdatesserviceModule() {
		super();
		ctx = TiApplication.getInstance().getApplicationContext();
		myReceiver = new MyReceiver();
		notificationName = getApplicationName(ctx);
		sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ctx);

	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
		Log.d(LCAT, "inside onAppCreate");

		// put module init code that needs to run when the application is
		// created
	}

	private class MyReceiver extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			Location location = intent
					.getParcelableExtra(LocationUpdatesService.EXTRA_LOCATION);
			if (location != null && hasListeners("LocationChanged")) {
				KrollDict res = new KrollDict();
				res.put("location", location.toString());
				res.put("time", location.getTime());
				res.put("latitude", location.getLatitude());
				res.put("longitude", location.getLongitude());
				res.put("accuracy", location.getAccuracy());
				res.put("bearing", location.getBearing());
				res.put("provider", location.getProvider());
				res.put("speed", location.getSpeed());
				res.put("speedaccuracymeterspersecond",
						location.getSpeedAccuracyMetersPerSecond());
				fireEvent("LocationChanged", res);
			}
		}
	}

	// Methods
	@Kroll.method
	public void config(KrollDict opts) {
		if (opts.containsKeyStartingWith("dbName"))
			dbName = opts.getString("dbName");
		if (opts.containsKeyStartingWith("notification")
				&& opts.get("notification") instanceof KrollDict) {
			KrollDict notification = opts.getKrollDict("notification");
			if (notification.containsKeyAndNotNull("name"))
				notificationName = notification.getString("name");
			if (notification.containsKeyAndNotNull("channel"))
				notificationChannel = notification.getString("channel");
			if (notification.containsKeyAndNotNull("startTracking"))
				startTracking = notification.getString("startTracking");
			if (notification.containsKeyAndNotNull("stopTracking"))
				stopTracking = notification.getString("stopTracking");
		}
		dbName = opts.getString("dbName");

	}

	@Kroll.method
	public void requestLocationUpdates(KrollDict opts) {
		if (opts.containsKeyStartingWith("interval"))
			interval = opts.getInt("interval");
		if (opts.containsKeyStartingWith("duration"))
			duration = opts.getInt("duration");
		if (duration > 0) {
			Timer timer = new Timer();
			timer.schedule(new TimerTask() {
				@Override
				public void run() {
					mService.removeLocationUpdates();
				}
			}, duration * 1000);

		}
		mService.requestLocationUpdates();
		LocalBroadcastManager.getInstance(ctx).registerReceiver(myReceiver,
				new IntentFilter(LocationUpdatesService.ACTION_BROADCAST));

	}

	/*
	 * public static void fireLocation(Location location) { if
	 * (hasListeners("LocationChanged")) { KrollDict res = new KrollDict();
	 * res.put("latitude", location.getLatitude()); res.put("longitude",
	 * location.getLongitude()); res.put("time", location.getTime());
	 * fireEvent("LocationChanged", res); } }
	 */

	@Kroll.method
	public void removeLocationUpdates() {
		mService.removeLocationUpdates();
		if (mBound) {
			// Unbind from the service. This signals to the service that this
			// activity is no longer
			// in the foreground, and the service can respond by promoting
			// itself to a foreground
			// service.
			ctx.unbindService(mServiceConnection);
			mBound = false;
		}

	}

	@Override
	public void onStart(Activity activity) {
		rootActivityClassName = TiApplication.getInstance()
				.getApplicationContext().getPackageName()
				+ "."
				+ TiApplication.getAppRootOrCurrentActivity().getClass()
						.getSimpleName();
		Log.d(LCAT, "Module started " + rootActivityClassName);
		super.onStart(activity);
	}

	private static String getApplicationName(Context context) {
		ApplicationInfo applicationInfo = context.getApplicationInfo();
		int stringId = applicationInfo.labelRes;
		return stringId == 0 ? applicationInfo.nonLocalizedLabel.toString()
				: context.getString(stringId);
	}

	// Monitors the state of the connection to the service.
	private final ServiceConnection mServiceConnection = new ServiceConnection() {

		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			LocationUpdatesService.LocalBinder binder = (LocationUpdatesService.LocalBinder) service;
			mService = binder.getService();
			mBound = true;
			KrollDict res = new KrollDict();
			res.put("connected", true);
			if (hasListeners("ServiceConnectionChanged"))
				fireEvent("ServiceConnectionChanged", mBound);

		}

		@Override
		public void onServiceDisconnected(ComponentName name) {
			mService = null;
			mBound = false;
			KrollDict res = new KrollDict();
			res.put("connected", true);
			if (hasListeners("ServiceConnectionChanged"))
				fireEvent("ServiceConnectionChanged", mBound);
		}
	};

}
